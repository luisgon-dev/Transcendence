---
phase: 01-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Transcendence.WebAPI/Transcendence.WebAPI.csproj
  - Transcendence.Service/Transcendence.Service.csproj
  - Transcendence.Service.Core/Transcendence.Service.Core.csproj
  - Transcendence.WebAPI/Program.cs
  - Transcendence.Service/Program.cs
  - Transcendence.WebAPI/appsettings.json
  - Transcendence.Service/appsettings.json
  - Transcendence.Service.Core/Services/Cache/CacheService.cs
  - Transcendence.Service.Core/Services/Cache/ICacheService.cs
  - Transcendence.Service.Core/Services/Extensions/ServiceCollectionExtensions.cs
autonomous: true

must_haves:
  truths:
    - "HybridCache can store and retrieve values across L1 (memory) and L2 (Redis)"
    - "Cache stampede protection prevents duplicate API calls on cache miss"
    - "Redis connection is pooled and configured for production use"
    - "Cache TTL configuration is externalized to appsettings.json"
  artifacts:
    - path: "Transcendence.Service.Core/Services/Cache/CacheService.cs"
      provides: "HybridCache wrapper service"
      min_lines: 40
    - path: "Transcendence.Service.Core/Services/Cache/ICacheService.cs"
      provides: "Cache service interface"
      exports: ["GetOrCreateAsync", "RemoveByTagAsync"]
    - path: "Transcendence.WebAPI/Program.cs"
      provides: "HybridCache + Redis DI configuration"
      contains: "AddHybridCache"
  key_links:
    - from: "Transcendence.Service.Core/Services/Cache/CacheService.cs"
      to: "Microsoft.Extensions.Caching.Hybrid.HybridCache"
      via: "constructor injection"
      pattern: "HybridCache.*cache"
    - from: "Transcendence.WebAPI/Program.cs"
      to: "StackExchange.Redis"
      via: "AddStackExchangeRedisCache"
      pattern: "AddStackExchangeRedisCache.*Redis"
---

<objective>
Establish two-tier caching infrastructure with HybridCache (L1 memory + L2 Redis) and stampede protection.

Purpose: Prevent rate limit violations and cache stampede issues by implementing production-grade caching before any data fetching enhancements.
Output: Fully configured HybridCache with Redis backend, reusable cache service, and externalized TTL configuration.
</objective>

<execution_context>
@/Users/kronic/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kronic/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Install HybridCache and Redis packages</name>
  <files>
Transcendence.WebAPI/Transcendence.WebAPI.csproj
Transcendence.Service/Transcendence.Service.csproj
Transcendence.Service.Core/Transcendence.Service.Core.csproj
  </files>
  <action>
Add the following NuGet packages to all three projects (WebAPI, Service, Service.Core):
- Microsoft.Extensions.Caching.Hybrid (version 10.0.2 or latest)
- Microsoft.Extensions.Caching.StackExchangeRedis (version 10.0.2 or latest)
- StackExchange.Redis (version 2.8.16 or latest)

Use `dotnet add package` for each project. Ensure versions are compatible with .NET 10.

DO NOT add Polly or custom retry libraries—Hangfire already provides exponential backoff, and Camille handles Riot API retries. Adding extra retry layers creates confusion about which layer is responsible for what.
  </action>
  <verify>
Run `dotnet restore` in solution root. Check that all three .csproj files contain the new PackageReferences. Build the solution with `dotnet build` to ensure no conflicts.
  </verify>
  <done>
All three projects reference HybridCache, StackExchangeRedis packages. Solution builds successfully with no package conflicts.
  </done>
</task>

<task type="auto">
  <name>Configure Redis and HybridCache in Program.cs files</name>
  <files>
Transcendence.WebAPI/Program.cs
Transcendence.Service/Program.cs
Transcendence.WebAPI/appsettings.json
Transcendence.Service/appsettings.json
  </files>
  <action>
In both WebAPI/Program.cs and Service/Program.cs, add Redis and HybridCache configuration AFTER AddDbContext but BEFORE building the app.

1. Add Redis connection string to appsettings.json in both projects:
```json
"ConnectionStrings": {
  "MainDatabase": "<existing>",
  "Redis": "localhost:6379"
}
```

2. In Program.cs for both projects, add:
```csharp
// Configure Redis distributed cache
builder.Services.AddStackExchangeRedisCache(options =>
{
    options.Configuration = builder.Configuration.GetConnectionString("Redis");
    options.InstanceName = "Transcendence_";
});

// Configure HybridCache with L1/L2 TTL relationship
builder.Services.AddHybridCache(options =>
{
    options.DefaultEntryOptions = new HybridCacheEntryOptions
    {
        Expiration = TimeSpan.FromHours(1),           // L2 Redis TTL
        LocalCacheExpiration = TimeSpan.FromMinutes(5) // L1 Memory TTL (shorter than L2)
    };
});
```

WHY L1 < L2: L1 (MemoryCache) expires first, forcing a check to Redis (L2), which may still have fresh data. This prevents stale-while-distributed-fresh scenarios where one server has stale in-memory cache but Redis has fresh data.

DO NOT hard-code TTLs in service layer—these defaults can be overridden per call. Configuration in appsettings is handled in Task 3.
  </action>
  <verify>
Start both WebAPI and Service projects. Check logs for Redis connection attempt (StackExchange.Redis logs on startup). Run `dotnet run` for each and confirm no startup errors related to caching.
  </verify>
  <done>
Both projects start successfully with HybridCache and Redis configured. No connection errors in logs. Redis connection string present in appsettings.json for both projects.
  </done>
</task>

<task type="auto">
  <name>Create reusable CacheService wrapper</name>
  <files>
Transcendence.Service.Core/Services/Cache/ICacheService.cs
Transcendence.Service.Core/Services/Cache/CacheService.cs
Transcendence.Service.Core/Services/Extensions/ServiceCollectionExtensions.cs
  </files>
  <action>
Create a domain-friendly cache service wrapper to centralize cache key generation, TTL configuration, and tag-based invalidation.

1. Create `Services/Cache/ICacheService.cs`:
```csharp
namespace Transcendence.Service.Core.Services.Cache;

public interface ICacheService
{
    Task<T> GetOrCreateAsync<T>(
        string key,
        Func<CancellationToken, Task<T>> factory,
        TimeSpan? expiration = null,
        TimeSpan? localExpiration = null,
        string[]? tags = null,
        CancellationToken cancellationToken = default);

    Task RemoveByTagAsync(string tag, CancellationToken cancellationToken = default);
}
```

2. Create `Services/Cache/CacheService.cs`:
```csharp
using Microsoft.Extensions.Caching.Hybrid;

namespace Transcendence.Service.Core.Services.Cache;

public class CacheService(HybridCache cache) : ICacheService
{
    public async Task<T> GetOrCreateAsync<T>(
        string key,
        Func<CancellationToken, Task<T>> factory,
        TimeSpan? expiration = null,
        TimeSpan? localExpiration = null,
        string[]? tags = null,
        CancellationToken cancellationToken = default)
    {
        var options = new HybridCacheEntryOptions
        {
            Expiration = expiration,
            LocalCacheExpiration = localExpiration
        };

        return await cache.GetOrCreateAsync(
            key,
            factory,
            options,
            tags,
            cancellationToken);
    }

    public async Task RemoveByTagAsync(string tag, CancellationToken cancellationToken = default)
    {
        await cache.RemoveByTagAsync(tag, cancellationToken);
    }
}
```

3. Register in `ServiceCollectionExtensions.cs` AddTranscendenceCore method:
```csharp
services.AddScoped<ICacheService, CacheService>();
```

WHY wrapper: Centralizes cache key patterns, makes testing easier (mock ICacheService instead of HybridCache), provides domain-specific abstraction over infrastructure.

DO NOT add custom stampede protection logic—HybridCache guarantees only one concurrent caller executes factory for a given key. Manual locking is redundant and error-prone.
  </action>
  <verify>
Build Service.Core project with `dotnet build`. Check that CacheService compiles without errors. Verify ServiceCollectionExtensions registers ICacheService -> CacheService mapping.
  </verify>
  <done>
CacheService wrapper created with GetOrCreateAsync and RemoveByTagAsync methods. Registered in DI container. Service.Core builds successfully.
  </done>
</task>

</tasks>

<verification>
1. Run both WebAPI and Service projects simultaneously
2. Check Hangfire dashboard (existing) to confirm no startup errors
3. Verify Redis connection via logs (StackExchange.Redis logs connection on startup)
4. Test cache by calling any existing API endpoint twice—second call should be faster (L1 hit)
5. Confirm no rate limit or cache-related errors in application logs
</verification>

<success_criteria>
- HybridCache configured in both WebAPI and Service projects with Redis L2 backend
- Redis connection string externalized to appsettings.json
- L1 TTL (5min) is shorter than L2 TTL (1hr) preventing stale-distributed-fresh scenarios
- CacheService wrapper provides domain-friendly abstraction over HybridCache
- Both projects start successfully with no caching-related errors
- Solution builds cleanly with all new dependencies resolved
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md`
</output>
