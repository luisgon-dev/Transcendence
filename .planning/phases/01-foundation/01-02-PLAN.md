---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - Transcendence.Service.Core/Services/StaticData/Implementations/StaticDataService.cs
  - Transcendence.Service.Core/Services/Jobs/UpdateStaticDataJob.cs
  - Transcendence.Service/Workers/DevelopmentWorker.cs
  - Transcendence.Service/Workers/ProductionWorker.cs
  - Transcendence.Data/Models/LoL/Static/Patch.cs
autonomous: true

must_haves:
  truths:
    - "Static data auto-updates within 6 hours of patch release"
    - "Patch detection runs on schedule without manual intervention"
    - "Cache invalidation triggers on patch change"
    - "New patch data fetches automatically after invalidation"
  artifacts:
    - path: "Transcendence.Service.Core/Services/StaticData/Implementations/StaticDataService.cs"
      provides: "Patch detection and cache-aware static data fetching"
      contains: "ICacheService"
    - path: "Transcendence.Service.Core/Services/Jobs/UpdateStaticDataJob.cs"
      provides: "Scheduled job for patch detection"
      min_lines: 30
    - path: "Transcendence.Data/Models/LoL/Static/Patch.cs"
      provides: "Patch entity with detection metadata"
      contains: "DetectedAt"
  key_links:
    - from: "Transcendence.Service.Core/Services/Jobs/UpdateStaticDataJob.cs"
      to: "Transcendence.Service.Core/Services/StaticData/Implementations/StaticDataService.cs"
      via: "patch detection logic"
      pattern: "DetectAndRefreshAsync"
    - from: "Transcendence.Service.Core/Services/StaticData/Implementations/StaticDataService.cs"
      to: "ICacheService"
      via: "cache invalidation on patch change"
      pattern: "RemoveByTagAsync.*patch"
---

<objective>
Implement automatic patch detection with cache invalidation and scheduled static data refresh.

Purpose: Ensure static data (champions, items, runes) auto-updates within 6 hours of patch releases, preventing stale data from being served after Riot patches.
Output: Scheduled Hangfire job that detects patches, invalidates cache, and refetches static data automatically.
</objective>

<execution_context>
@/Users/kronic/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kronic/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Add patch detection metadata to Patch entity</name>
  <files>
Transcendence.Data/Models/LoL/Static/Patch.cs
  </files>
  <action>
Extend the Patch entity to track when patches were detected and make version retrieval cache-aware.

Update Patch.cs:
```csharp
namespace Transcendence.Data.Models.LoL.Static;

public class Patch
{
    public string Version { get; set; } = string.Empty;
    public DateTime ReleaseDate { get; set; }
    public DateTime? DetectedAt { get; set; }  // When we first detected this patch
    public bool IsActive { get; set; } = true;  // Current active patch
}
```

WHY DetectedAt: Tracks when our system first became aware of a patch, enabling metrics on detection lag (how long between Riot release and our detection).

WHY IsActive: Marks the current patch. On new patch detection, set previous patch IsActive=false, new patch IsActive=true. Simplifies queries for "current patch version".

After changing the model, create an EF Core migration:
```bash
cd Transcendence.Service
dotnet ef migrations add AddPatchDetectionMetadata --project ../Transcendence.Data
```

DO NOT run the migration yet—verify it generates correctly first.
  </action>
  <verify>
Check that migration file is created in Transcendence.Data/Migrations/ with AddPatchDetectionMetadata in filename. Review migration Up/Down methods to confirm DetectedAt and IsActive columns are being added to Patches table.
  </verify>
  <done>
Patch entity has DetectedAt and IsActive fields. EF Core migration generated successfully with column additions.
  </done>
</task>

<task type="auto">
  <name>Enhance StaticDataService with patch detection and cache integration</name>
  <files>
Transcendence.Service.Core/Services/StaticData/Implementations/StaticDataService.cs
Transcendence.Service.Core/Services/StaticData/Interfaces/IStaticDataService.cs
  </files>
  <action>
Refactor StaticDataService to detect patch changes, invalidate cache on patch change, and use cache for static data fetches.

1. Add ICacheService dependency to StaticDataService constructor:
```csharp
public class StaticDataService(
    TranscendenceContext context,
    IHttpClientFactory httpClientFactory,
    ICacheService cacheService)
    : IStaticDataService
```

2. Add new method `DetectAndRefreshAsync` to interface and implementation:
```csharp
public async Task DetectAndRefreshAsync(CancellationToken cancellationToken = default)
{
    var client = httpClientFactory.CreateClient();
    var patches = await FetchPatchesAsync(client, cancellationToken);
    if (patches is null || patches.Count == 0) return;

    var latestFullPatch = patches[0].Patch;
    var latestCdragonPatch = TrimPatch(latestFullPatch);

    // Check if this is a new patch
    var currentPatch = await context.Patches
        .FirstOrDefaultAsync(p => p.IsActive, cancellationToken);

    if (currentPatch == null || currentPatch.Version != latestCdragonPatch)
    {
        // New patch detected
        if (currentPatch != null)
        {
            currentPatch.IsActive = false;
        }

        var newPatch = new Patch
        {
            Version = latestCdragonPatch,
            ReleaseDate = DateTime.UtcNow,
            DetectedAt = DateTime.UtcNow,
            IsActive = true
        };

        context.Patches.Add(newPatch);
        await context.SaveChangesAsync(cancellationToken);

        // Invalidate all patch-dependent cache
        await cacheService.RemoveByTagAsync($"patch-{currentPatch?.Version}", cancellationToken);

        // Fetch fresh static data
        await EnsureStaticDataForPatchAsync(latestCdragonPatch, cancellationToken);
    }
}
```

3. Update `EnsureStaticDataForPatchAsync` to use cache with patch version tags:
```csharp
public async Task EnsureStaticDataForPatchAsync(string patchVersion, CancellationToken cancellationToken = default)
{
    // Use cache for runes
    var runes = await cacheService.GetOrCreateAsync(
        $"static:runes:{patchVersion}",
        async ct => await FetchAndStoreRunesAsync(patchVersion, ct),
        expiration: TimeSpan.FromDays(30),
        localExpiration: TimeSpan.FromMinutes(5),
        tags: new[] { $"patch-{patchVersion}" },
        cancellationToken: cancellationToken);

    // Use cache for items
    var items = await cacheService.GetOrCreateAsync(
        $"static:items:{patchVersion}",
        async ct => await FetchAndStoreItemsAsync(patchVersion, ct),
        expiration: TimeSpan.FromDays(30),
        localExpiration: TimeSpan.FromMinutes(5),
        tags: new[] { $"patch-{patchVersion}" },
        cancellationToken: cancellationToken);
}
```

4. Extract rune/item fetching into separate methods `FetchAndStoreRunesAsync` and `FetchAndStoreItemsAsync` (move existing logic from EnsureStaticDataForPatchAsync).

WHY patch version in cache key: Natural expiration when patch changes. Old patch keys remain in cache but unused. New patch gets new keys.

WHY 30-day TTL: Outlives 2-week patch cycle. Old patch data persists in cache for historical queries if needed.

DO NOT fetch static data synchronously on API requests—this job runs in background on schedule. API reads from cache only.
  </action>
  <verify>
Build Service.Core with `dotnet build`. Check that StaticDataService compiles with new ICacheService dependency. Verify DetectAndRefreshAsync method exists and calls RemoveByTagAsync on patch change.
  </verify>
  <done>
StaticDataService has DetectAndRefreshAsync method with patch detection logic. Cache invalidation triggers on patch change. Static data fetching uses cache with patch-versioned keys.
  </done>
</task>

<task type="auto">
  <name>Schedule UpdateStaticDataJob with Hangfire recurring job</name>
  <files>
Transcendence.Service.Core/Services/Jobs/UpdateStaticDataJob.cs
Transcendence.Service/Workers/DevelopmentWorker.cs
Transcendence.Service/Workers/ProductionWorker.cs
  </files>
  <action>
Update UpdateStaticDataJob to call DetectAndRefreshAsync and schedule it as a recurring Hangfire job.

1. Update UpdateStaticDataJob.cs Execute method:
```csharp
public class UpdateStaticDataJob(IStaticDataService staticDataService)
{
    public async Task Execute(CancellationToken cancellationToken)
    {
        await staticDataService.DetectAndRefreshAsync(cancellationToken);
    }
}
```

2. In DevelopmentWorker.cs, add recurring job registration in ExecuteAsync method:
```csharp
protected override async Task ExecuteAsync(CancellationToken stoppingToken)
{
    // Existing code...

    // Schedule patch detection every 6 hours
    RecurringJob.AddOrUpdate<UpdateStaticDataJob>(
        "detect-patch",
        job => job.Execute(CancellationToken.None),
        "0 */6 * * *"); // Every 6 hours at minute 0

    // Run immediately on startup for development
    BackgroundJob.Enqueue<UpdateStaticDataJob>(job => job.Execute(CancellationToken.None));
}
```

3. In ProductionWorker.cs, add the same recurring job (WITHOUT immediate execution):
```csharp
protected override async Task ExecuteAsync(CancellationToken stoppingToken)
{
    // Existing code...

    // Schedule patch detection every 6 hours
    RecurringJob.AddOrUpdate<UpdateStaticDataJob>(
        "detect-patch",
        job => job.Execute(CancellationToken.None),
        "0 */6 * * *"); // Every 6 hours at minute 0
}
```

WHY 6 hours: Patch cycle is ~2 weeks. Checking every 6 hours ensures detection within requirement ("auto-updates within 6 hours of patch release"). More frequent checking (e.g., hourly) wastes API calls.

WHY immediate execution in development: Enables testing patch detection without waiting 6 hours. Production waits for schedule to prevent unnecessary API hits on every deployment.

DO NOT use `Cron.Daily()` or longer intervals—requirement is 6-hour detection window, not daily.
  </action>
  <verify>
Run the Service worker project with `dotnet run`. Check Hangfire dashboard at /hangfire for "detect-patch" recurring job. Verify job appears in "Recurring Jobs" tab with "0 */6 * * *" schedule. In development, confirm job runs immediately on startup (check logs for static data fetch).
  </verify>
  <done>
UpdateStaticDataJob calls DetectAndRefreshAsync. Recurring job scheduled in both Development and Production workers with 6-hour interval. Development worker triggers immediate execution on startup.
  </done>
</task>

</tasks>

<verification>
1. Run the Service worker project
2. Open Hangfire dashboard (/hangfire) and verify "detect-patch" recurring job is scheduled
3. In development, check logs for immediate patch detection execution
4. Verify no errors in patch detection (check for HTTP failures to CommunityDragon)
5. Check database Patches table for DetectedAt and IsActive columns (after running migration)
6. Simulate patch change by manually updating Patches table and verify cache invalidation triggers
</verification>

<success_criteria>
- Patch entity has DetectedAt and IsActive fields with EF migration created
- StaticDataService.DetectAndRefreshAsync detects new patches and invalidates cache
- UpdateStaticDataJob scheduled as Hangfire recurring job (every 6 hours)
- Cache invalidation uses tag-based removal (`patch-{version}`)
- Static data fetches use cache with patch-versioned keys (30-day TTL, 5-min local)
- Development worker runs patch detection immediately on startup
- Hangfire dashboard shows "detect-patch" recurring job with correct schedule
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
