---
phase: 01-foundation
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - Transcendence.Data/Models/LoL/Match/Match.cs
  - Transcendence.Data/Models/LoL/Match/MatchParticipant.cs
  - Transcendence.Data/TranscendenceContext.cs
  - Transcendence.Service.Core/Services/RiotApi/Implementations/MatchService.cs
  - Transcendence.Service.Core/Services/Jobs/RetryFailedMatchesJob.cs
autonomous: true

must_haves:
  truths:
    - "Failed match fetches retry with exponential backoff (30s, 60s, 120s, 300s)"
    - "Permanently unfetchable matches stop retrying after max attempts"
    - "Match retention windows (2 years matches, 1 year timelines) are checked before fetching"
    - "Riot API rate limit headers are respected (via Camille built-in handling)"
  artifacts:
    - path: "Transcendence.Data/Models/LoL/Match/Match.cs"
      provides: "Match entity with FetchStatus and retry tracking"
      contains: "FetchStatus"
    - path: "Transcendence.Service.Core/Services/RiotApi/Implementations/MatchService.cs"
      provides: "Match fetching with retry logic and retention window checks"
      contains: "RetryCount"
    - path: "Transcendence.Service.Core/Services/Jobs/RetryFailedMatchesJob.cs"
      provides: "Scheduled job to retry failed match fetches"
      min_lines: 30
  key_links:
    - from: "Transcendence.Service.Core/Services/RiotApi/Implementations/MatchService.cs"
      to: "Hangfire.BackgroundJob"
      via: "exponential backoff scheduling"
      pattern: "BackgroundJob\\.Schedule.*TimeSpan"
    - from: "Transcendence.Service.Core/Services/Jobs/RetryFailedMatchesJob.cs"
      to: "Transcendence.Data.Models.LoL.Match.Match"
      via: "query for TemporaryFailure status"
      pattern: "FetchStatus\\.TemporaryFailure"
---

<objective>
Implement safe retry logic with exponential backoff and retention window checks to prevent infinite retry loops and API blacklisting.

Purpose: Fetch and preserve match data while it exists within Riot's retention windows (2 years for matches, 1 year for timelines), marking unfetchable data to stop wasting API calls.
Output: FetchStatus tracking on Match entity, retry job with exponential backoff, retention window validation before API calls.
</objective>

<execution_context>
@/Users/kronic/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kronic/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Add FetchStatus tracking to Match entity</name>
  <files>
Transcendence.Data/Models/LoL/Match/Match.cs
Transcendence.Data/TranscendenceContext.cs
  </files>
  <action>
Extend Match entity to track fetch status, retry count, and timestamps for failure diagnosis.

1. Update Match.cs:
```csharp
namespace Transcendence.Data.Models.LoL.Match;

public enum FetchStatus
{
    Unfetched = 0,
    Success = 1,
    TemporaryFailure = 2,
    PermanentlyUnfetchable = 3,
    OutsideRetentionWindow = 4
}

public class Match
{
    public Guid Id { get; set; }
    public string? MatchId { get; set; }
    public long MatchDate { get; set; }
    public int Duration { get; set; }
    public string? Patch { get; set; }
    public string? QueueType { get; set; }
    public string? EndOfGameResult { get; set; }

    // Fetch metadata
    public FetchStatus Status { get; set; } = FetchStatus.Unfetched;
    public int RetryCount { get; set; } = 0;
    public DateTime? FetchedAt { get; set; }
    public DateTime? LastAttemptAt { get; set; }
    public string? LastErrorMessage { get; set; }

    public List<Summoner> Summoners { get; set; } = [];
    public ICollection<MatchParticipant> Participants { get; set; } = new List<MatchParticipant>();
}
```

WHY FetchStatus enum: Distinguishes between temporary failures (worth retrying) and permanent failures (stop trying). OutsideRetentionWindow prevents fetching data Riot API no longer has.

WHY LastAttemptAt: Enables calculating backoff delay for next retry. Prevents retrying too soon after failure.

2. Add global query filter to TranscendenceContext.cs OnModelCreating to exclude unfetchable matches from normal queries:
```csharp
modelBuilder.Entity<Match>()
    .HasQueryFilter(m => m.Status != FetchStatus.PermanentlyUnfetchable);
```

WHY query filter: Unfetchable matches are historical records (for metrics) but shouldn't appear in normal queries. Use `IgnoreQueryFilters()` if you need to access them for admin/reporting.

3. Create EF Core migration:
```bash
cd Transcendence.Service
dotnet ef migrations add AddMatchFetchStatus --project ../Transcendence.Data
```

DO NOT add custom retry state machines—Hangfire already provides job retry scheduling with exponential backoff. FetchStatus tracks outcome, Hangfire tracks scheduling.
  </action>
  <verify>
Check that migration file is created with AddMatchFetchStatus in filename. Review migration to confirm Status, RetryCount, FetchedAt, LastAttemptAt, LastErrorMessage columns are being added to Matches table. Verify enum is created as int column (default EF behavior).
  </verify>
  <done>
Match entity has FetchStatus enum and retry tracking fields. Global query filter excludes PermanentlyUnfetchable matches. EF Core migration generated successfully.
  </done>
</task>

<task type="auto">
  <name>Implement retry logic with retention window checks in MatchService</name>
  <files>
Transcendence.Service.Core/Services/RiotApi/Implementations/MatchService.cs
Transcendence.Service.Core/Services/RiotApi/Interfaces/IMatchService.cs
  </files>
  <action>
Add retry logic with exponential backoff and retention window validation to MatchService.

1. Add new method to IMatchService interface:
```csharp
Task<bool> FetchMatchWithRetryAsync(string matchId, string region, CancellationToken cancellationToken = default);
```

2. Implement in MatchService.cs:
```csharp
public async Task<bool> FetchMatchWithRetryAsync(string matchId, string region, CancellationToken cancellationToken = default)
{
    var match = await _matchRepository.GetByMatchIdAsync(matchId, cancellationToken)
                ?? new Match { MatchId = matchId, Status = FetchStatus.Unfetched };

    // Check retention window BEFORE attempting fetch
    var matchAge = DateTime.UtcNow - DateTimeOffset.FromUnixTimeMilliseconds(match.MatchDate).DateTime;
    if (matchAge.TotalDays > 730) // 2 years
    {
        match.Status = FetchStatus.OutsideRetentionWindow;
        match.LastAttemptAt = DateTime.UtcNow;
        match.LastErrorMessage = "Match data outside Riot API 2-year retention window";
        await _context.SaveChangesAsync(cancellationToken);
        return false;
    }

    try
    {
        match.LastAttemptAt = DateTime.UtcNow;

        // Camille handles rate limiting automatically
        var matchDto = await _riotApi.MatchV5().GetMatchAsync(region, matchId);

        // Parse and store match data (existing logic)
        // ... populate match fields from matchDto ...

        match.Status = FetchStatus.Success;
        match.FetchedAt = DateTime.UtcNow;
        match.LastErrorMessage = null;
        await _context.SaveChangesAsync(cancellationToken);

        return true;
    }
    catch (Exception ex)
    {
        match.RetryCount++;
        match.LastErrorMessage = ex.Message;

        if (match.RetryCount >= 5)
        {
            match.Status = FetchStatus.PermanentlyUnfetchable;
            _logger.LogWarning("Match {MatchId} marked unfetchable after {RetryCount} attempts: {Error}",
                matchId, match.RetryCount, ex.Message);
        }
        else
        {
            match.Status = FetchStatus.TemporaryFailure;

            // Schedule retry with exponential backoff: 30s, 60s, 120s, 300s
            var delays = new[] { 30, 60, 120, 300 };
            var delay = TimeSpan.FromSeconds(delays[Math.Min(match.RetryCount - 1, delays.Length - 1)]);

            BackgroundJob.Schedule<IMatchService>(
                service => service.FetchMatchWithRetryAsync(matchId, region, CancellationToken.None),
                delay);

            _logger.LogInformation("Match {MatchId} retry scheduled in {Delay}s (attempt {RetryCount})",
                matchId, delay.TotalSeconds, match.RetryCount);
        }

        await _context.SaveChangesAsync(cancellationToken);
        return false;
    }
}
```

WHY retention window check first: Prevents wasting API calls on data Riot no longer has. Match data >2 years old returns 404.

WHY exponential backoff: Eventual consistency delays from Riot API (match just ended, data processing). Backing off gives Riot time to make data available.

WHY max 5 attempts: Balances persistence with avoiding infinite loops. After 5 failures over ~10 minutes, data is likely permanently unavailable.

DO NOT implement custom rate limiting—Camille SDK already parses X-Rate-Limit-* headers and respects Retry-After. Adding custom throttling creates double-throttling and delays your own requests unnecessarily.
  </action>
  <verify>
Build Service.Core with `dotnet build`. Check that MatchService compiles with new retry logic. Verify BackgroundJob.Schedule calls exist with exponential delay calculation. Confirm retention window check happens before API call.
  </verify>
  <done>
MatchService.FetchMatchWithRetryAsync implements exponential backoff (30s, 60s, 120s, 300s). Retention window validation prevents fetching matches >2 years old. Max 5 retry attempts before marking unfetchable.
  </done>
</task>

<task type="auto">
  <name>Create RetryFailedMatchesJob for periodic retry cleanup</name>
  <files>
Transcendence.Service.Core/Services/Jobs/RetryFailedMatchesJob.cs
Transcendence.Service/Workers/ProductionWorker.cs
  </files>
  <action>
Create a periodic job that retries TemporaryFailure matches that may have been missed by scheduled retries (e.g., due to service restarts).

1. Create RetryFailedMatchesJob.cs:
```csharp
using Microsoft.EntityFrameworkCore;
using Transcendence.Data;
using Transcendence.Data.Models.LoL.Match;
using Transcendence.Service.Core.Services.RiotApi.Interfaces;

namespace Transcendence.Service.Core.Services.Jobs;

public class RetryFailedMatchesJob(
    TranscendenceContext context,
    IMatchService matchService,
    ILogger<RetryFailedMatchesJob> logger)
{
    public async Task Execute(CancellationToken cancellationToken)
    {
        // Find matches with TemporaryFailure that haven't been attempted in last 10 minutes
        var cutoff = DateTime.UtcNow.AddMinutes(-10);
        var failedMatches = await context.Matches
            .IgnoreQueryFilters() // Include PermanentlyUnfetchable for complete view
            .Where(m => m.Status == FetchStatus.TemporaryFailure && m.LastAttemptAt < cutoff)
            .Take(100) // Batch size to prevent overwhelming API
            .ToListAsync(cancellationToken);

        logger.LogInformation("Retrying {Count} failed matches", failedMatches.Count);

        foreach (var match in failedMatches)
        {
            await matchService.FetchMatchWithRetryAsync(match.MatchId!, "na1", cancellationToken);
        }
    }
}
```

WHY 10-minute cutoff: Prevents immediate re-attempts. Gives exponential backoff time to work. Only retries matches that fell through the cracks.

WHY batch size 100: Prevents rate limit exhaustion if many matches failed. Process in chunks, respecting Camille's built-in rate limiting.

2. Schedule in ProductionWorker.cs:
```csharp
// Schedule retry job every hour
RecurringJob.AddOrUpdate<RetryFailedMatchesJob>(
    "retry-failed-matches",
    job => job.Execute(CancellationToken.None),
    Cron.Hourly);
```

WHY hourly: Safety net for missed retries, not primary retry mechanism. Exponential backoff (Task 2) is primary. Hourly cleanup catches edge cases.

DO NOT make this job the primary retry mechanism—it's a safety net. Individual match retry scheduling (Task 2) handles most cases.
  </action>
  <verify>
Build Service.Core and Service projects. Run Service worker and check Hangfire dashboard for "retry-failed-matches" recurring job. Verify job appears with Cron.Hourly schedule. Check logs to confirm job can query TemporaryFailure matches without errors.
  </verify>
  <done>
RetryFailedMatchesJob queries TemporaryFailure matches and retries in batches. Scheduled hourly in ProductionWorker as safety net for missed retries.
  </done>
</task>

</tasks>

<verification>
1. Run Service worker and check Hangfire dashboard for "retry-failed-matches" recurring job
2. Simulate match fetch failure by providing invalid match ID and verify:
   - FetchStatus changes to TemporaryFailure
   - RetryCount increments
   - BackgroundJob.Schedule called with exponential delay
   - After 5 failures, status changes to PermanentlyUnfetchable
3. Check database Matches table for new columns (Status, RetryCount, FetchedAt, LastAttemptAt, LastErrorMessage)
4. Verify retention window check by creating match with MatchDate >2 years ago
5. Confirm normal queries exclude PermanentlyUnfetchable matches (query filter active)
</verification>

<success_criteria>
- Match entity has FetchStatus enum with Unfetched, Success, TemporaryFailure, PermanentlyUnfetchable, OutsideRetentionWindow states
- Retry logic implements exponential backoff (30s, 60s, 120s, 300s) with max 5 attempts
- Retention window validation prevents fetching matches >2 years old
- Global query filter excludes PermanentlyUnfetchable matches from normal queries
- RetryFailedMatchesJob runs hourly as safety net for missed retries
- Camille SDK rate limiting is trusted (no custom throttling added)
- Database migration created with all new Match fields
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
