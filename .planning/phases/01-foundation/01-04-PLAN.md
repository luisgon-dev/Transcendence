---
phase: 01-foundation
plan: 04
type: execute
wave: 3
depends_on: ["01-03"]
files_modified:
  - Transcendence.Data/Models/LoL/Account/Rank.cs
  - Transcendence.Data/Models/LoL/Match/MatchParticipant.cs
  - Transcendence.Service.Core/Services/RiotApi/DTOs/SummonerProfileResponse.cs
  - Transcendence.Service.Core/Services/RiotApi/DTOs/MatchHistoryResponse.cs
  - Transcendence.WebAPI/Controllers/SummonerController.cs
autonomous: true

must_haves:
  truths:
    - "API responses include data age metadata (FetchedAt timestamps)"
    - "Clients can determine data freshness without guessing"
    - "Static data responses show patch version and fetch time"
    - "Match data responses show when each match was last fetched"
  artifacts:
    - path: "Transcendence.Service.Core/Services/RiotApi/DTOs/SummonerProfileResponse.cs"
      provides: "Profile DTO with data age metadata"
      contains: "DataAge"
    - path: "Transcendence.Service.Core/Services/RiotApi/DTOs/MatchHistoryResponse.cs"
      provides: "Match history DTO with fetch timestamps"
      contains: "FetchedAt"
    - path: "Transcendence.Data/Models/LoL/Account/Rank.cs"
      provides: "Rank entity with fetch timestamp"
      contains: "UpdatedAt"
  key_links:
    - from: "Transcendence.WebAPI/Controllers/SummonerController.cs"
      to: "Transcendence.Service.Core/Services/RiotApi/DTOs/SummonerProfileResponse.cs"
      via: "API response mapping"
      pattern: "return.*SummonerProfileResponse"
---

<objective>
Add data freshness metadata to API responses so clients can display data age and understand staleness.

Purpose: Enable clients (desktop app, web) to show users when data was last updated, improving transparency and user trust.
Output: All API responses include FetchedAt/UpdatedAt timestamps and age calculations.
</objective>

<execution_context>
@/Users/kronic/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kronic/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-PLAN.md
@.planning/phases/01-foundation/01-03-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Add timestamp metadata to data entities</name>
  <files>
Transcendence.Data/Models/LoL/Account/Rank.cs
Transcendence.Data/Models/LoL/Match/MatchParticipant.cs
  </files>
  <action>
Add UpdatedAt/FetchedAt timestamps to entities that don't already have them.

1. Update Rank.cs:
```csharp
public class Rank
{
    public Guid Id { get; set; }
    public string SummonerId { get; set; } = string.Empty;
    public string QueueType { get; set; } = string.Empty;
    public string Tier { get; set; } = string.Empty;
    public string Division { get; set; } = string.Empty;
    public int LeaguePoints { get; set; }
    public int Wins { get; set; }
    public int Losses { get; set; }
    public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;  // When rank data was last fetched

    public Summoner Summoner { get; set; }
}
```

WHY UpdatedAt on Rank: Rank data is near-real-time (<5 minutes requirement). Clients need to know if rank is stale (e.g., fetched 2 hours ago vs 2 minutes ago).

2. MatchParticipant already has Match.FetchedAt via relationship. No changes needed—inherit timestamp from Match entity.

3. Create EF Core migration:
```bash
cd Transcendence.Service
dotnet ef migrations add AddDataFreshnessTimestamps --project ../Transcendence.Data
```

DO NOT add CreatedAt/UpdatedAt to ALL entities reflexively—only add where clients need to display data age. Excessive timestamps bloat database and add maintenance burden.
  </action>
  <verify>
Check that migration file is created with AddDataFreshnessTimestamps in filename. Review migration to confirm UpdatedAt column is being added to Ranks table. Build solution with `dotnet build` to ensure no compilation errors.
  </verify>
  <done>
Rank entity has UpdatedAt field. EF Core migration generated successfully. Solution builds without errors.
  </done>
</task>

<task type="auto">
  <name>Create response DTOs with data age metadata</name>
  <files>
Transcendence.Service.Core/Services/RiotApi/DTOs/SummonerProfileResponse.cs
Transcendence.Service.Core/Services/RiotApi/DTOs/MatchHistoryResponse.cs
Transcendence.Service.Core/Services/RiotApi/DTOs/DataAgeMetadata.cs
  </files>
  <action>
Create response DTOs that include data freshness information for API clients.

1. Create DataAgeMetadata.cs (reusable component):
```csharp
namespace Transcendence.Service.Core.Services.RiotApi.DTOs;

public class DataAgeMetadata
{
    public DateTime FetchedAt { get; set; }
    public TimeSpan Age => DateTime.UtcNow - FetchedAt;
    public string AgeDescription => Age.TotalMinutes < 5
        ? "Just now"
        : Age.TotalHours < 1
            ? $"{(int)Age.TotalMinutes} minutes ago"
            : Age.TotalDays < 1
                ? $"{(int)Age.TotalHours} hours ago"
                : $"{(int)Age.TotalDays} days ago";
}
```

WHY AgeDescription: Human-friendly text for UI. Clients can use raw Age for logic, AgeDescription for display.

2. Create SummonerProfileResponse.cs:
```csharp
namespace Transcendence.Service.Core.Services.RiotApi.DTOs;

public class SummonerProfileResponse
{
    public string Puuid { get; set; } = string.Empty;
    public string GameName { get; set; } = string.Empty;
    public string TagLine { get; set; } = string.Empty;
    public int SummonerLevel { get; set; }
    public int ProfileIconId { get; set; }

    // Rank data
    public RankInfo? SoloRank { get; set; }
    public RankInfo? FlexRank { get; set; }

    // Data freshness
    public DataAgeMetadata ProfileAge { get; set; } = new();
    public DataAgeMetadata RankAge { get; set; } = new();
}

public class RankInfo
{
    public string Tier { get; set; } = string.Empty;
    public string Division { get; set; } = string.Empty;
    public int LeaguePoints { get; set; }
    public int Wins { get; set; }
    public int Losses { get; set; }
}
```

3. Create MatchHistoryResponse.cs:
```csharp
namespace Transcendence.Service.Core.Services.RiotApi.DTOs;

public class MatchHistoryResponse
{
    public List<MatchSummary> Matches { get; set; } = new();
}

public class MatchSummary
{
    public string MatchId { get; set; } = string.Empty;
    public DateTime MatchDate { get; set; }
    public int Duration { get; set; }
    public string QueueType { get; set; } = string.Empty;
    public string Result { get; set; } = string.Empty; // Win/Loss

    // Participant stats
    public int ChampionId { get; set; }
    public string ChampionName { get; set; } = string.Empty;
    public int Kills { get; set; }
    public int Deaths { get; set; }
    public int Assists { get; set; }

    // Data freshness
    public DataAgeMetadata DataAge { get; set; } = new();
}
```

WHY separate ProfileAge and RankAge: Profile data (name, level) changes rarely. Rank data changes frequently. Different freshness expectations.

DO NOT include FetchedAt on every nested object—only at meaningful boundaries (profile, rank, match). Over-granular timestamps bloat responses.
  </action>
  <verify>
Build Service.Core with `dotnet build`. Verify all new DTOs compile. Check that DataAgeMetadata calculates Age and AgeDescription properties correctly (readonly properties with logic).
  </verify>
  <done>
Response DTOs created with data age metadata. DataAgeMetadata provides FetchedAt, Age, and AgeDescription. SummonerProfileResponse has ProfileAge and RankAge. MatchHistoryResponse has DataAge per match.
  </done>
</task>

<task type="auto">
  <name>Update API controllers to populate data age metadata</name>
  <files>
Transcendence.WebAPI/Controllers/SummonerController.cs
  </files>
  <action>
Update existing SummonerController endpoints to map entities to new DTOs with data age metadata.

1. Find existing summoner profile endpoint (likely GET /api/summoner/{riotId}) and update response mapping:
```csharp
[HttpGet("{riotId}")]
public async Task<ActionResult<SummonerProfileResponse>> GetProfile(string riotId)
{
    // Existing logic to fetch summoner and rank data
    var summoner = await _summonerService.GetByRiotIdAsync(riotId);
    if (summoner == null) return NotFound();

    var soloRank = await _rankService.GetRankAsync(summoner.Id, "RANKED_SOLO_5x5");
    var flexRank = await _rankService.GetRankAsync(summoner.Id, "RANKED_FLEX_SR");

    var response = new SummonerProfileResponse
    {
        Puuid = summoner.Puuid,
        GameName = summoner.GameName,
        TagLine = summoner.TagLine,
        SummonerLevel = summoner.SummonerLevel,
        ProfileIconId = summoner.ProfileIconId,

        SoloRank = soloRank != null ? new RankInfo
        {
            Tier = soloRank.Tier,
            Division = soloRank.Division,
            LeaguePoints = soloRank.LeaguePoints,
            Wins = soloRank.Wins,
            Losses = soloRank.Losses
        } : null,

        FlexRank = flexRank != null ? new RankInfo
        {
            Tier = flexRank.Tier,
            Division = flexRank.Division,
            LeaguePoints = flexRank.LeaguePoints,
            Wins = flexRank.Wins,
            Losses = flexRank.Losses
        } : null,

        ProfileAge = new DataAgeMetadata
        {
            FetchedAt = summoner.UpdatedAt ?? DateTime.UtcNow
        },

        RankAge = new DataAgeMetadata
        {
            FetchedAt = soloRank?.UpdatedAt ?? flexRank?.UpdatedAt ?? DateTime.UtcNow
        }
    };

    return Ok(response);
}
```

2. Update match history endpoint similarly (if exists), or create placeholder for Phase 2.

WHY use existing UpdatedAt/FetchedAt: Entities already track these (from Task 1 and Plan 03). No need to recalculate—just map to DTO.

WHY fallback to UtcNow: If data has never been fetched (unlikely but possible), show current time rather than null. Prevents null reference errors in clients.

DO NOT fetch fresh data to update timestamps in GET endpoints—timestamps reflect last background fetch. GET endpoints are read-only, not triggers for refreshes.
  </action>
  <verify>
Build WebAPI with `dotnet build`. Start WebAPI with `dotnet run` and test summoner profile endpoint (e.g., `curl http://localhost:5000/api/summoner/TestPlayer-NA1`). Verify response includes ProfileAge and RankAge with FetchedAt timestamps and Age calculations.
  </verify>
  <done>
SummonerController endpoints map entity timestamps to DataAgeMetadata in responses. API returns FetchedAt, Age, and AgeDescription for profile and rank data. Clients can display data freshness.
  </done>
</task>

</tasks>

<verification>
1. Run database migrations to add UpdatedAt columns
2. Start WebAPI and call summoner profile endpoint
3. Verify response JSON includes:
   - ProfileAge.FetchedAt (timestamp)
   - ProfileAge.Age (duration)
   - ProfileAge.AgeDescription (human-friendly text)
   - RankAge.FetchedAt (timestamp)
4. Confirm AgeDescription changes based on Age (e.g., "Just now" for <5 min, "X minutes ago" for <1 hr)
5. Check that match history responses (if implemented) also include DataAge metadata
</verification>

<success_criteria>
- Rank entity has UpdatedAt timestamp field with EF migration created
- DataAgeMetadata DTO provides FetchedAt, Age, and AgeDescription properties
- SummonerProfileResponse includes ProfileAge and RankAge metadata
- MatchHistoryResponse includes DataAge per match summary
- API responses populate data age metadata from entity timestamps
- Clients can display data freshness in UI (e.g., "Rank updated 2 minutes ago")
- Age calculation is client-side safe (readonly properties, no serialization issues)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-04-SUMMARY.md`
</output>
